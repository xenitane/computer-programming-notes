/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);

// not-a-real-css-parser.ts
var PSEUDO_ELEMENT_REGEX = /(?=::(?:before|after|first-letter))/;
var parseRulesets = (source) => source.trim().split("}").filter((ruleset) => ruleset.contains("{")).map((ruleset) => {
  const [selector, declarations] = ruleset.split("{");
  const trimmedSelector = selector.trim().replace(/\n/g, " ");
  return {
    selector: trimmedSelector,
    declarations
  };
});
var parseSelector = (selector) => selector.split(",").map((selector2) => selector2.trim());
var hasPseudoElements = (selector) => PSEUDO_ELEMENT_REGEX.test(selector);
var splitPseudoElements = (selector) => selector.split(PSEUDO_ELEMENT_REGEX);

// main.ts
var import_obsidian = require("obsidian");
var CLASSNAME_TAG = "classname:";
var makeScopedStyles = (rootSelector, source) => parseRulesets(source).map(({ selector, declarations }) => {
  if (hasPseudoElements(selector)) {
    return parseSelector(selector).map((selector2) => {
      const [selectorHead, pseudoElement] = splitPseudoElements(selector2);
      return `${rootSelector} :is(${selectorHead})${pseudoElement != null ? pseudoElement : ""} {${declarations}}`;
    }).join(",");
  }
  return `${rootSelector} :is(${selector}) {${declarations}}`;
}).join("\n");
var main_default = class extends import_obsidian.Plugin {
  onload() {
    this.registerMarkdownCodeBlockProcessor("style", (source, element) => {
      element.createEl("style", {
        text: makeScopedStyles(".markdown-preview-view", source)
      });
    });
    this.registerMarkdownPostProcessor((element) => {
      var _a;
      if (element.hasClass("next-class-skip")) {
        return;
      }
      if (this.lastClassName !== void 0) {
        element.classList.add(...this.lastClassName.split(/\s+/));
        this.lastClassName = void 0;
      }
      const codeElements = element.querySelectorAll("code");
      const classElement = [...codeElements].find((element2) => element2.innerText.trim().startsWith(CLASSNAME_TAG));
      if (classElement) {
        this.lastClassName = classElement.innerText.slice(CLASSNAME_TAG.length);
        if (((_a = classElement.parentElement) == null ? void 0 : _a.childElementCount) === 1) {
          classElement.parentElement.remove();
        }
        element.classList.add("next-class-skip");
      }
    });
  }
};
